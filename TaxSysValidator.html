<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>TaxSys Validator (Parcel/Bill/Message)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
       
        /* === Tokens (match JotForm) === */
        :root {
            --label: #4a4a4a;
            --muted: #6b7280;
            --placeholder: #9ca3af;
            --text: #111827;
            --border: #e5e7eb;
            --border-hover: #d1d5db;
            --ring: #2563eb;
            --radius: 8px;
            --gap: 16px;
            --input-h: 44px;
            --ta-min-h: 240px;
            --li-padding-v: 12px;
            --li-padding-h: 10px;
        }

        html, body {
            width: 100%;
            max-width: 100%
        }

        body {
            font: 16px Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
            margin: 0;
            padding: 0;
            color: var(--text)
        }

        .row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--gap)
        }

        @media (max-width:900px) {
            .row {
                grid-template-columns: 1fr
            }
        }

        .field {
            display: block;
            padding: var(--li-padding-v) 0
        }

        label {
            display: block;
            margin: 0 0 8px;
            font-weight: 600;
            color: var(--label);
            line-height: 1.25rem
        }

        .optional {
            font-weight: 400;
            color: var(--muted)
        }

        input, textarea {
            display: block;
            width: 100%;
            padding: 12px 14px;
            box-sizing: border-box;
            border: 1px solid var(--border);
            border-radius: var(--radius);
           
            outline: none;
            transition: border-color .15s ease, box-shadow .15s ease;
            font-size: 16px
        }

        input {
            height: var(--input-h)
        }

        textarea {
            min-height: var(--ta-min-h);
            resize: vertical
        }

            input:hover, textarea:hover {
                border-color: var(--border-hover)
            }

            input:focus, textarea:focus {
                border-color: var(--ring);
                box-shadow: 0 0 0 3px rgb(37 99 235 / 12%)
            }

        ::placeholder {
            color: var(--placeholder)
        }

        .msg {
            margin-top: 6px;
            min-height: 1.1rem;
            font-size: 12px;
            color: var(--muted)
        }

        .bad {
            color: #9f1d1d
        }

        .substatus {
            font-size: 12px;
            opacity: .9;
            margin-top: 6px;
            color: var(--muted)
        }

            .substatus.bad {
                color: #9f1d1d
            }

        .hint {
            opacity: .8;
            font-size: 12px;
            margin-top: 8px;
            color: var(--muted)
        }

        .hidden {
            display: none !important
        }
    </style>
    <script src="https://js.jotform.com/JotFormCustomWidget.min.js"></script>
</head>
<body>
    <div id="pbWrap" class="row">
        <div class="field" id="parcelField">
            <label for="parcel" id="label_parcel">Parcel Number (Optional)</label>
            <input id="parcel" placeholder="Enter parcel number (Optional)" autocomplete="off" inputmode="text" />
            <div id="m_parcel" class="msg hidden"></div>
        </div>
        <div class="field" id="billField">
            <label for="bill" id="label_bill">Bill Number (Optional)</label>
            <input id="bill" placeholder="Enter bill number (Optional)" autocomplete="off" inputmode="numeric" />
            <div id="m_bill" class="msg hidden"></div>
        </div>
    </div>

    <div id="msgWrap" class="field hidden">
        <label for="freeText" id="label_message">Enter your message in the space provided below:</label>
        <textarea id="freeText" placeholder=""></textarea>
        <div id="m_message" class="msg hidden"></div>
        <div class="substatus hidden" id="m_msg_parcel"></div>
        <div class="substatus hidden" id="m_msg_bill"></div>
    </div>

    <div id="standaloneHint" class="hint" style="display:none">(Opened outside Jotform.)</div>

    <script>
  // ======== CONFIG ========
  const PARCEL_LEN = 13;
  const BILL_LENS  = [9, 11];

  const UNIQUE_PARCEL = "typeA32";
  const UNIQUE_BILL   = "billNumber";

  // ======== ENDPOINTS ========
  let BASE = "https://zendeskfunctionapp-egfydygfdmavfxg9.westus-01.azurewebsites.net";
  let PARCEL_URL = (v) => `${BASE}/api/public/parcels/${encodeURIComponent(v)}`;
  let BILL_URL   = (v) => `${BASE}/api/public/bills/${encodeURIComponent(v)}`;

  // ======== UTILS ========
  const $ = (id) => document.getElementById(id);
  const debounce = (fn, ms) => { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), ms); }; };
  const safeDecode = (v)=>{ if(!v) return v; try{ v=decodeURIComponent(v);}catch{} try{ v=decodeURIComponent(v);}catch{} return v.replace(/\+/g,' '); };
  const normalizeToken = (s) => (s || "").replace(/[^0-9a-z]/gi, "").toUpperCase();

        // ======== URL BREAKER (message only) ========
        // Break URLs so Jotform won't auto-link them in emails/inbox/PDF.
        // Keeps it readable: https://example.com -> https[:]//example[.]com
        function breakUrlsPreserveReadable(text) {
            if (!text) return text;

            // Match http(s)://... or www....
            const re = /\bhttps?:\/\/[^\s<>()]+|\bwww\.[^\s<>()]+/gi;

            return text.replace(re, (url) => {
                let out = url;

                // Break protocol if present
                out = out.replace(/^https?:\/\//i, (m) => m.replace("://", "[:]//"));

                // Break dots (prevents linkification)
                out = out.replace(/\./g, "[.]");

                return out;
            });
        }


        // Preserve caret when we rewrite textarea value
        function setTextareaValuePreserveCaret(el, nextValue) {
            if (!el) return;
            const start = el.selectionStart;
            const end = el.selectionEnd;
            const prev = el.value;

            if (prev === nextValue) return;

            // Simple caret preservation (works well for most typing cases)
            el.value = nextValue;
            try {
                const delta = nextValue.length - prev.length;
                el.setSelectionRange(start + delta, end + delta);
            } catch { }
        }


  function requestResize() {
    try {
      const h = Math.max(document.documentElement.scrollHeight, document.body.scrollHeight, 180);
      if (window.JFCustomWidget?.requestFrameResize) JFCustomWidget.requestFrameResize({ height: h });
      else if (window.JFCustomWidget?.setHeight)     JFCustomWidget.setHeight(h);
    } catch {}
  }

  // Only show messages when invalid/error
  const showMsg = (id, txt, bad=true) => {
    const e = $(id); if(!e) return;
    e.className = (e.className.includes('substatus') ? 'substatus' : 'msg') + (bad ? ' bad' : '');
    e.textContent = txt || '';
    e.classList.remove('hidden');
    requestResize();
  };
  const hideMsg = (id) => { const e=$(id); if(!e) return; e.textContent=""; e.classList.add('hidden'); requestResize(); };

  async function getJson(url){
    const res = await fetch(url, { method:"GET", mode:"cors", cache:"no-store" });
    let data=null; try{ data=await res.json(); }catch{}
    return { ok: res.ok, status: res.status, data };
  }

  // ======== EXTRACTORS ========
        function extractFirstParcel(s) {
            const m = (s || "").match(new RegExp(`\\b[0-9A-Za-z]{${PARCEL_LEN}}\\b`, 'g')) || [];
            const cand = normalizeToken(m[0] || "");
            // Require at least one digit to avoid matching lorem-ipsum words / random tokens
            if (!/\d/.test(cand)) return "";
            return cand;
        }
  const RE_BILL_CANDIDATES = /\d{11}|\d{9}/g;
  const isDigit = (c) => c >= "0" && c <= "9";
  function isDigitBounded(text, startIdx, len) {
    const endIdx = startIdx + len;
    const prev = startIdx > 0 ? text[startIdx - 1] : "";
    const next = endIdx < text.length ? text[endIdx] : "";
    return !isDigit(prev) && !isDigit(next);
  }
  function extractFirstBill(s){
    const str = s || "";
    const matches = [...str.matchAll(RE_BILL_CANDIDATES)];
    for (const mm of matches) {
      const val = mm[0];
      const start = mm.index ?? str.indexOf(val);
      if (isDigitBounded(str, start, val.length)) return val;
    }
    return "";
  }
  const looksLikeBillLen = (v) => (/^\d{9}$/.test(v || "") || /^\d{11}$/.test(v || ""));

  // ======== QUERY PARAMS ========
  const params      = new URLSearchParams(location.search);
  const variant     = (params.get("variant") || "both").toLowerCase();
  const requireMode = (params.get("require") || "any").toLowerCase();

  const labelOverrides = {
    parcelLabel: safeDecode(params.get("parcelLabel")),
    billLabel:   safeDecode(params.get("billLabel")),
    parcelPh:    safeDecode(params.get("parcelPh")),
    billPh:      safeDecode(params.get("billPh")),
    messageLabel:safeDecode(params.get("messageLabel")),
    messagePh:   safeDecode(params.get("messagePh")),
  };

  const urlParcels = safeDecode(params.get("parcelsEndpoint"));
  const urlBills   = safeDecode(params.get("billsEndpoint"));
  const urlBase    = safeDecode(params.get("base"));
  if (urlBase)   BASE = urlBase;
  if (urlParcels) PARCEL_URL = (v) => `${urlParcels.replace(/\/$/,'')}/${encodeURIComponent(v)}`;
  if (urlBills)   BILL_URL   = (v) => `${urlBills.replace(/\/$/,'')}/${encodeURIComponent(v)}`;

  // Should message box extract numbers?
  const detectFromMessage = (params.get("detectFromMessage") === "1") || (variant === "message");
  const writeFromMessage  = (params.get("writeMessage") === "1");

  // ======== STATE ========
  const state = { parcel:"", bill:"", parcelOk:false, billOk:false, message:"" };
  let lastCheckedParcel = null, lastCheckedBill = null;
  let prevParcelCandidate = null, prevBillCandidate = null;

  let parcelLocked = false;
  let billLocked   = false;

  // ======== ENCODING ========
  function fixedEncode(p, b) {
    const P = normalizeToken(p);
    const B = String(b || "").replace(/\D/g, "");
    const p13 = (("0000000000000" + P).slice(-13)).slice(0,13);
    const b11 = (("00000000000"  + B).slice(-11)).slice(0,11);
    return `${p13}|${b11}`;
  }
  function padRight(str, len, ch=" ") {
    str = String(str ?? "");
    if (str.length >= len) return str.slice(0, len);
    return str + ch.repeat(len - str.length);
  }
  function makeCompound500() {
    const msg500 = padRight(state.message || "", 500, " ");
    const pair   = fixedEncode(state.parcel, state.bill);
    return `${msg500}|${pair}`;
  }

  // ======== BRIDGE ========
  function populateFormField(uniqueName, value) {
    try { window.parent.postMessage({ action: "populate", field: uniqueName, value: value ?? "" }, "*"); } catch {}
  }
  function syncToForm() {
    if (variant !== "message" || writeFromMessage) {
      if (state.parcelOk && state.parcel) populateFormField(UNIQUE_PARCEL, state.parcel);
      if (state.billOk   && state.bill)   populateFormField(UNIQUE_BILL,   state.bill);
    }
  }

  function emitWidgetValue(){
    const value = makeCompound500();
    if (window.JFCustomWidget) {
      try { JFCustomWidget.setValue(value); } catch {}
      try { JFCustomWidget.sendData({ valid: true, value }); } catch {}
      requestResize();
    }
    syncToForm();
  }
  const currentSubmitValue = () => makeCompound500();

  // ======== UI ========
  function applyVariantUI(){
    const pb = $("pbWrap"), msg = $("msgWrap");
    if (variant === "message"){ pb?.classList.add("hidden"); msg?.classList.remove("hidden"); }
    else {
      msg?.classList.add("hidden"); pb?.classList.remove("hidden");
      if (variant === "parcel") $("billField")?.classList.add("hidden");
      if (variant === "bill")   $("parcelField")?.classList.add("hidden");
    }
    requestResize();
  }

  function ensureOptionalLabel(el, required) {
    if (!el) return;
    const raw  = el.textContent || "";
    const base = raw.replace(/\s*\(Optional\)\s*$/i, "");
    el.textContent = base;
    el.querySelectorAll(".optional").forEach(n => n.remove());
    if (!required) {
      const opt = document.createElement("span");
      opt.className = "optional";
      opt.textContent = " (Optional)";
      el.appendChild(opt);
    }
  }

  // ======== VALIDATORS (messages only on invalid) ========
  async function validateParcel(raw, {alsoMsg=false} = {}){
    const val = normalizeToken(raw);
    if(!val){
      state.parcel=""; state.parcelOk=false; emitWidgetValue();
      hideMsg("m_parcel"); if (alsoMsg) hideMsg("m_msg_parcel");
      return;
    }
    if (val.length !== PARCEL_LEN){
      state.parcel=""; state.parcelOk=false; emitWidgetValue();
      const msg = `Parcel must be ${PARCEL_LEN} characters.`;
      showMsg("m_parcel", msg, true);
      if (alsoMsg) showMsg("m_msg_parcel", msg, true);
      return;
    }
    if (val === lastCheckedParcel && prevParcelCandidate === val) return;
    lastCheckedParcel = val;

    // suppress "validating…" text
    hideMsg("m_parcel"); if (alsoMsg) hideMsg("m_msg_parcel");

    try{
      const r = await getJson(PARCEL_URL(val));
      if(r.ok && (r.data?.exists===true || r.data?.ok===true)){
        state.parcel = normalizeToken(r.data.normalized || r.data.parcel || val);
        state.parcelOk = true; emitWidgetValue();
        // valid => keep quiet
        hideMsg("m_parcel"); if (alsoMsg) hideMsg("m_msg_parcel");
      } else {
        state.parcel=""; state.parcelOk=false; emitWidgetValue();
        const msg = "✗ Invalid parcel number. Please check and retype again";
        showMsg("m_parcel", msg, true);
        if (alsoMsg) showMsg("m_msg_parcel", msg, true);
      }
    }catch{
      state.parcel=""; state.parcelOk=false; emitWidgetValue();
      const msg = "⚠ Error contacting parcel validator.";
      showMsg("m_parcel", msg, true);
      if (alsoMsg) showMsg("m_msg_parcel", "⚠ Error contacting parcel validator", true);
    }
  }

  async function validateBill(raw, {alsoMsg=false} = {}){
    const val = String(raw || "").replace(/\D/g, "");
    if(!val){
      state.bill=""; state.billOk=false; emitWidgetValue();
      hideMsg("m_bill"); if (alsoMsg) hideMsg("m_msg_bill");
      return;
    }
    if (!looksLikeBillLen(val)){
      state.bill=""; state.billOk=false; emitWidgetValue();
      const msg = "Bill numbers are 9 or 11 digits.";
      showMsg("m_bill", msg, true);
      if (alsoMsg) showMsg("m_msg_bill", msg, true);
      return;
    }
    if (val === lastCheckedBill && prevBillCandidate === val) return;
    lastCheckedBill = val;

    // suppress "validating…" text
    hideMsg("m_bill"); if (alsoMsg) hideMsg("m_msg_bill");

    try{
      const r = await getJson(BILL_URL(val));
      if(r.ok && (r.data?.exists===true || r.data?.ok===true)){
        state.bill = String(r.data.normalized || r.data.bill || val).replace(/\D/g,"");
        state.billOk = true; emitWidgetValue();
        // valid => keep quiet
        hideMsg("m_bill"); if (alsoMsg) hideMsg("m_msg_bill");
      } else {
        state.bill=""; state.billOk=false; emitWidgetValue();
        const msg = "✗ Invalid bill number. Please check and retype again";
        showMsg("m_bill", msg, true);
        if (alsoMsg) showMsg("m_msg_bill", msg, true);
      }
    }catch{
      state.bill=""; state.billOk=false; emitWidgetValue();
      const msg = "⚠ Error contacting bill validator.";
      showMsg("m_bill", msg, true);
      if (alsoMsg) showMsg("m_msg_bill", "⚠ Error contacting bill validator", true);
    }
  }

  const debouncedParcel = debounce((v)=>validateParcel(v, {alsoMsg: variant==="message"}), 250);
  const debouncedBill   = debounce((v)=>validateBill(v,   {alsoMsg: variant==="message"}), 250);

  // ======== MESSAGE VARIANT ========
        function onMessageInput(rawText) {
            // NEW: break URLs before storing/extracting/submitting
            const sanitizedText = breakUrlsPreserveReadable(rawText || "");
            state.message = sanitizedText;

            // Keep existing functionality: extraction still works (parcel/bill unaffected)
            if (!detectFromMessage) { emitWidgetValue(); return; }

            let candParcel = extractFirstParcel(sanitizedText);
            let candBill = extractFirstBill(sanitizedText);

            if (candParcel && candBill && candParcel === candBill) {
                if (candParcel.length === PARCEL_LEN && !looksLikeBillLen(candBill)) candBill = "";
                else if (looksLikeBillLen(candBill) && candParcel.length !== PARCEL_LEN) candParcel = "";
                else candBill = "";
            }

            // quiet while parsing
            hideMsg("m_msg_parcel"); hideMsg("m_msg_bill");
            prevParcelCandidate = candParcel || null;
            prevBillCandidate = candBill || null;

            if (candParcel && !parcelLocked) state.parcel = candParcel;
            if (candBill && !billLocked) state.bill = candBill;

            emitWidgetValue();
            if (state.parcel) debouncedParcel(state.parcel);
            if (state.bill) debouncedBill(state.bill);
        }


  // ======== REQUIRE RULES ========
  function passesRequireRule() {
    switch (requireMode) {
      case "none":   return true;
      case "parcel": return !!state.parcel && state.parcelOk;
      case "bill":   return !!state.bill   && state.billOk;
      case "both":   return (!!state.parcel && state.parcelOk) && (!!state.bill && state.billOk);
      case "any":
      default:
        const anyProvided = !!state.parcel || !!state.bill;
        const anyValid    = (state.parcel && state.parcelOk) || (state.bill && state.billOk);
        return anyProvided ? anyValid : true;
    }
  }
  function explainRequireFailure() {
    // Only show when truly failing; these are invalid cases so it's fine to display
    if (requireMode === "parcel")      showMsg("m_parcel", "Parcel required and must be valid.", true);
    else if (requireMode === "bill")   showMsg("m_bill",   "Bill required and must be valid.", true);
    else if (requireMode === "both") {
      if (!state.parcelOk) showMsg("m_parcel","Parcel must be valid.", true);
      if (!state.billOk)   showMsg("m_bill","Bill must be valid.", true);
    } else {
      if (state.parcel && !state.parcelOk) showMsg("m_parcel","Parcel appears invalid.", true);
      if (state.bill && !state.billOk)     showMsg("m_bill","Bill appears invalid.", true);
    }
  }

  // ======== BOOT ========
  (function init(){
    // label/placeholder overrides
    if (labelOverrides.parcelLabel){ const l=$("label_parcel"); if(l){ l.textContent = labelOverrides.parcelLabel; } }
    if (labelOverrides.billLabel){   const l=$("label_bill");   if(l){ l.textContent = labelOverrides.billLabel;   } }
    if (labelOverrides.messageLabel){ const l=$("label_message"); if(l) l.textContent=labelOverrides.messageLabel; }
    if (labelOverrides.parcelPh && $("parcel")) $("parcel").placeholder = labelOverrides.parcelPh;
    if (labelOverrides.billPh   && $("bill"))   $("bill").placeholder   = labelOverrides.billPh;
    if (labelOverrides.messagePh&& $("freeText")) $("freeText").placeholder = labelOverrides.messagePh;

    const parcelRequired = (requireMode === "parcel" || requireMode === "both");
    const billRequired   = (requireMode === "bill"   || requireMode === "both");
    ensureOptionalLabel($("label_parcel"), parcelRequired);
    ensureOptionalLabel($("label_bill"),   billRequired);

    applyVariantUI();

    // Inputs
    document.addEventListener("input",  (e)=>{ if(e?.target?.id==="parcel"){ parcelLocked = true; state.parcel = normalizeToken(e.target.value); emitWidgetValue(); debouncedParcel(e.target.value); }}, true);
    document.addEventListener("change", (e)=>{ if(e?.target?.id==="parcel"){ parcelLocked = true; state.parcel = normalizeToken(e.target.value); emitWidgetValue(); debouncedParcel(e.target.value); }}, true);
    document.addEventListener("focus",  (e)=>{ if(e?.target?.id==="parcel"){ parcelLocked = true; }}, true);

    document.addEventListener("input",  (e)=>{ if(e?.target?.id==="bill"){ billLocked = true; state.bill = String(e.target.value||"").replace(/\D/g,""); emitWidgetValue(); debouncedBill(state.bill); }}, true);
    document.addEventListener("change", (e)=>{ if(e?.target?.id==="bill"){ billLocked = true; state.bill = String(e.target.value||"").replace(/\D/g,""); emitWidgetValue(); debouncedBill(state.bill); }}, true);
    document.addEventListener("focus",  (e)=>{ if(e?.target?.id==="bill"){ billLocked = true; }}, true);

      document.addEventListener("input", (e) => {
          if (e?.target?.id === "freeText") {
              const el = e.target;
              const next = breakUrlsPreserveReadable(el.value || "");
              setTextareaValuePreserveCaret(el, next); // NEW: update visible text, keep caret
              onMessageInput(el.value);                // keep existing flow
          }
      }, true);

      document.addEventListener("change", (e) => {
          if (e?.target?.id === "freeText") {
              const el = e.target;
              const next = breakUrlsPreserveReadable(el.value || "");
              el.value = next;          // change event: caret doesn't matter much
              onMessageInput(el.value); // keep existing flow
          }
      }, true);


    if (window.JFCustomWidget && typeof JFCustomWidget.subscribe === "function"){
      JFCustomWidget.subscribe("ready", () => {
        const sParcels = JFCustomWidget.getWidgetSetting?.("parcelsEndpoint");
        const sBills   = JFCustomWidget.getWidgetSetting?.("billsEndpoint");
        const sBase    = JFCustomWidget.getWidgetSetting?.("baseUrl");
        if (sBase) BASE = sBase;
        if (sParcels) PARCEL_URL = (v) => `${sParcels.replace(/\/$/,'')}/${encodeURIComponent(v)}`;
        if (sBills)   BILL_URL   = (v) => `${sBills.replace(/\/$/,'')}/${encodeURIComponent(v)}`;

        state.parcel=""; state.bill=""; state.parcelOk=false; state.billOk=false; state.message="";
        parcelLocked = false; billLocked = false;
        emitWidgetValue(); requestResize();
      });

      JFCustomWidget.subscribe("submit", async () => {
          if ($("freeText")) {
              const el = $("freeText");
              const next = breakUrlsPreserveReadable(el.value || "");
              el.value = next;
              state.message = next;
          }

        if ($("parcel"))   state.parcel  = normalizeToken($("parcel").value);
        if ($("bill"))     state.bill    = String($("bill").value||"").replace(/\D/g,"");

        const needsParcelCheck = state.parcel && !state.parcelOk && state.parcel.length === PARCEL_LEN;
        const needsBillCheck   = state.bill   && !state.billOk   && looksLikeBillLen(state.bill);
        if (needsParcelCheck) await validateParcel(state.parcel);
        if (needsBillCheck)   await validateBill(state.bill);

        if (!passesRequireRule()) {
          explainRequireFailure();
          try { JFCustomWidget.sendSubmit({ valid: false, value: currentSubmitValue() }); return; } catch {}
          try { JFCustomWidget.sendSubmit(false); } catch {}
          return;
        }

        const payload = currentSubmitValue();
        try { JFCustomWidget.sendSubmit({ valid: true, value: payload }); return; } catch {}
        try { JFCustomWidget.sendSubmit(true); } catch {}
      });
    } else {
      const showHint=()=>{ const hint=$("standaloneHint"); if(hint) hint.style.display="block"; };
      if(document.readyState==="loading") document.addEventListener("DOMContentLoaded", showHint, {once:true}); else showHint();
    }
  })();
    </script>
</body>
</html>
